-- modified version of  http://www.andres-loeh.de/LambdaPi/prelude.lp

data Bool' :: Type = False' :: Bool' ; True' :: Bool'
data List (a :: Type) :: Type = Nil' :: List a ; Cons' :: a -> List a -> List a

primitive primAdd   :: Int -> Int -> Int
primitive primSub   :: Int -> Int -> Int
primitive primMod   :: Int -> Int -> Int
primitive primSqrt  :: Int -> Int
primitive primIntEq :: Int -> Int -> Bool'
primitive primIntLess :: Int -> Int -> Bool'

primitive primFix :: forall (i :: Int) . forall a . (a -> a) -> a 
let fix' = fix _

let id      = \a -> a
let const   = \x y -> x
let undefined = fix' id
let from    = fix' (\f n -> Cons' n (f (primAdd #1 n)))
let head    = listCase (\_ -> _) undefined (\x _ -> x)
let tail    = listCase (\_ -> _) undefined (\_ xs -> xs)
let nth     = fix' (\f n xs -> bool'Case (\_ -> _)
                     (f (primSub n #1) (tail xs))
                     (head xs)
                     (primIntEq #0 n))
let filter =
  \p -> fix' (\fil -> listCase (\_ -> _) Nil'
        (\x xs -> bool'Case (\_ -> _)
                     (fil xs)
                     (Cons' x (fil xs))
                     (p x)))
let takeWhile =
  \p -> fix' (\tw -> listCase (\_ -> _) Nil'
        (\x xs -> bool'Case (\_ -> _)
                     Nil'
                     (Cons' x (tw xs))
                     (p x)))
let and'    = \a b -> bool'Case (\_ -> _) False' b a
let or'     = \a b -> bool'Case (\_ -> _) b True' a
let not'    = bool'Case (\_ -> _) True' False'
let all     = \p -> fix' (\al -> listCase (\_ -> _) True' (\x xs -> and' (p x) (al xs)))
let intLEq  = \n m -> or' (primIntLess n m) (primIntEq n m)

let primes = fix' (\primes ->
   (Cons' #2 (Cons' #3 (filter (\x -> all (\i -> not' (primIntEq #0 (primMod x i))) (
        takeWhile (\p -> (\m -> or' (primIntLess p m) (primIntEq p m)) (primSqrt x)) primes
    )) (from #5)))
   ))

let nthPrimes = \n -> nth n primes
let int = nthPrimes #10000

data Nat :: Type = Zero :: Nat ; Succ :: Nat -> Nat
data Fin :: Nat -> Type = FZero :: forall {n} . Fin (Succ n) ; FSucc :: forall {n} . Fin n -> Fin (Succ n)
data Vec (a :: Type) :: Nat -> Type = Nil :: Vec a Zero ; Cons :: forall {n} . a -> Vec a n -> Vec a (Succ n)
data Eq {a :: Type} :: a -> a -> Type = Refl :: forall {x} . Eq x x

let vec = Vec _
{-
primitive bool'Case :: forall m . m False' -> m True' -> forall b . m b
primitive listCase  :: forall m . m Nil' -> (forall x xs . m (Cons' x xs)) -> forall b . m b
primitive eqCase :: forall (m :: forall x y . Eq x y -> _) . (forall x . m x x Refl) -> forall x y e . m x y e
primitive natCase :: forall m . m Zero -> (forall n . m (Succ n)) -> forall b . m b
-}
primitive natElim :: forall m . m Zero -> (forall n . m n -> m (Succ n)) -> forall b . m b
primitive finElim ::
  forall (m :: forall n . Fin n -> _) .
      (forall n . m (Succ n) FZero)
   -> (forall n f . m n f -> m (Succ n) (FSucc f))
   -> forall n f . m n f

primitive vecElim ::
  forall (m :: forall k . vec k -> _) .
         m Zero Nil
         -> (forall l x xs . m l xs -> m (Succ l) (Cons x xs))
         -> forall k xs . m k xs

-- addition of natural numbers
let plus =
  natElim
    (\_ -> _)           -- motive
    (\n -> n)                    -- case for Zero
    (\p rec n -> Succ (rec n))   -- case for Succ

-- predecessor, mapping 0 to 0
let pred =
  natElim
    (\_ -> _)
    Zero
    (\n' _ -> n')

-- a simpler elimination scheme for natural numbers
let natFold =
    \mz ms -> natElim
                   (\_ -> _)
                   mz
                   (\n' rec -> ms rec)

-- an eliminator for natural numbers that has special
-- cases for 0 and 1
let nat1Elim = \m m0 m1 ms -> natElim m m0
                            (\p rec -> natElim (\n -> m (Succ n)) m1 ms p)

-- an eliminator for natural numbers that has special
-- cases for 0, 1 and 2
let nat2Elim = \m m0 m1 m2 ms -> nat1Elim m m0 m1
                                (\p rec -> natElim (\n -> m (Succ (Succ n))) m2 ms p)

-- increment by one
let inc = natFold (Succ Zero) Succ

-- embed Fin into Nat
let finNat = finElim (\_ _ -> Nat)
                     (\_ -> Zero)
                     (\_ _ rec -> Succ rec)

-- unit type
let Unit = Fin 1
-- constructor
let U = FZero :: Unit
-- eliminator

let unitElim = \m mu -> finElim (nat1Elim (\n -> Fin n -> Type)
                                 (\_ -> Unit)
                                 (\x -> m x)
                                 (\_ _ _ -> Unit))
                      (natElim (\n -> natElim (\n -> Fin (Succ n) -> Type)
                                                (\x -> m x)
                                                (\_ _ _ -> Unit)
                                                n FZero)
                                mu
                                (\_ _ -> U))
                      (\n f _ -> finElim (\n f -> natElim (\n -> Fin (Succ n) -> Type)
                                                             (\x -> m x)
                                                             (\_ _ _ -> Unit)
                                                             n (FSucc f))
                                           (\_ -> U)
                                           (\_ _ _ -> U)
                                           n f)
                      1

-- empty type
let Void = Fin 0
-- eliminator

let voidElim =
  (\m -> finElim (natElim (\n -> Fin n -> Type)
                            (\x -> m x)
                            (\_ _ _ -> _))
                   (\_ -> U)
                   (\_ _ _ -> U)
                   0)

-- type of booleans 
let Bool = Fin 2 
-- constructors
let False = FZero :: Bool
let True  = FSucc FZero :: Bool
-- eliminator

let boolElim = \m mf mt -> finElim ( nat2Elim (\n -> Fin n -> Type)
                                    (\_ -> Unit) (\_ -> Unit)
                                    (\x -> m x)
                                    (\_ _ _ -> Unit))
                         ( nat1Elim (\n -> nat1Elim (\n -> Fin (Succ n) -> Type)
                                                      (\_ -> Unit)
                                                      (\x -> m x)
                                                      (\_ _ _ -> Unit)
                                                      n FZero)
                                    U mf (\_ _ -> U))
                         (\n f _ -> finElim (\n f -> nat1Elim (\n -> Fin (Succ n) -> Type)
                                                                  (\_ -> Unit)
                                                                  (\x -> m x)
                                                                  (\_ _ _ -> Unit)
                                                                  n (FSucc f))
                                              ( natElim
                                                  (\n -> natElim
                                                             (\n -> Fin (Succ (Succ n)) -> Type)
                                                             (\x -> m x)
                                                             (\_ _ _ -> Unit)
                                                             n (FSucc FZero))
                                                  mt (\_ _ -> U))
                                              (\n f _ -> finElim
                                                             (\n f -> natElim
                                                                         (\n -> Fin (Succ (Succ n)) -> Type)
                                                                         (\x -> m x)
                                                                         (\_ _ _ -> Unit)
                                                                         n (FSucc (FSucc f)))
                                                             (\_ -> U)
                                                             (\_ _ _ -> U)
                                                             n f)
                                              n f)
                         2


-- boolean not, and, or, equivalence, xor
let not = boolElim (\_ -> _) True False
let and = boolElim (\_ -> _) (\_ -> False) id
let or  = boolElim (\_ -> _) id (\_ -> True)
let iff = boolElim (\_ -> _) not id
let xor = boolElim (\_ -> _) id not

-- even, odd, isZero, isSucc
let even    = natFold True not
let odd     = natFold False not
let isZero  = natFold True (\_ -> False)
let isSucc  = natFold False (\_ -> True)

-- equality on natural numbers
let natEq =
  natElim
    (\_ -> _)
    (natElim
        (\_ -> _)
        True
        (\n' _ -> False))
    (\m' rec_m' -> natElim
                       (\_ -> _)
                       False
                       (\n' _ -> rec_m' n'))

-- "oh so true"
let Prop = boolElim (\_ -> _) Void Unit

-- reflexivity of equality on natural numbers
let pNatEqRefl =
  natElim
    (\n -> Prop (natEq n n))
    U
    (\n' rec -> rec)
--  :: forall (n :: Nat) . Prop (natEq n n)

-- alias for type-level negation 
let Not = \a -> a -> Void

-- Leibniz prinicple (look at the type signature)
let leibniz = \f x y -> eqCase
                 (\x y eq_x_y -> Eq (f x) (f y))
                 (\x -> Refl) x y

-- symmetry of (general) equality
let symm = \x y -> eqCase
             (\x y eq_x_y -> Eq y x)
             (\x -> Refl) x y

-- transitivity of (general) equality
let tran = \x y z eq_x_y -> eqCase
                          (\x y eq_x_y -> forall z . Eq y z -> Eq x z)
                          (\x z eq_x_z -> eq_x_z)
                          x y eq_x_y z

-- apply an equality proof on two types
let apply = eqCase (\a b _ -> a -> b) (\_ x -> x) _ _

let p1IsNot0 =
  (\p -> apply
                (leibniz
                         (natElim (\_ -> _) Void (\_ _ -> Unit))
                         1 0 p)
                U)

-- proof that 0 is not 1
let p0IsNot1 = \p -> p1IsNot0 (symm 0 1 p)

-- proof that zero is not a successor
let p0IsNoSucc = 
  natElim
    (\n -> Not (Eq 0 (Succ n)))
    p0IsNot1
    (\n' rec_n' eq_0_SSn' ->
      rec_n' (leibniz pred Zero (Succ (Succ n')) eq_0_SSn'))

-- generate a vector of given length from a specified element (replicate)

let replicate =
    natElim
      (\n -> forall a . a -> Vec a n)
      (\_ _ -> Nil)
      (\n' rec_n' a x -> Cons x (rec_n' a x))

-- alternative definition of replicate
let replicate' =
    natElim
      (\n -> _ -> vec n)
      (\_ -> Nil)
      (\n' rec_n' x -> Cons x (rec_n' x))

let replicate'' = \x -> natElim vec Nil (\n' rec_n' -> Cons x rec_n')

-- generate a vector of given length n, containing the natural numbers smaller than n
let fromto = natElim vec Nil (\n' rec_n' -> Cons n' rec_n')

-- append two vectors
let append = vecElim
             (\m _ -> forall n . vec n -> vec (plus m n))
             (\_ v -> v)
             (\m v vs rec n w -> Cons v (rec n w))

-- helper function for tail, see below
let tail' =
  \a -> vecElim (\m v -> forall n . Eq m (Succ n) -> Vec a n)
                    (\n eq_0_SuccN -> voidElim (\_ -> _)
                                                 ( p0IsNoSucc n eq_0_SuccN))
                    (\m' v vs rec_m' n eq_SuccM'_SuccN ->
                      eqCase
                             (\m' n e -> Vec a m' -> Vec a n)
                             (\_ v -> v)
                             m' n
                             (leibniz pred (Succ m') (Succ n) eq_SuccM'_SuccN) vs)

-- compute the tail of a vector
let tail = \n v -> tail' _ (Succ n) v n Refl

-- projection out of a vector
let at =
    vecElim (\n v -> Fin n -> _)
                    (\f -> voidElim (\_ -> _) f)
                    (\n' v vs rec_n' f_SuccN' ->
                      finElim (\n _ -> Eq n (Succ n') -> _)
                              (\n e -> v)
                              (\n f_N _ eq_SuccN_SuccN' ->
                                rec_n' (eqCase
                                               (\x y e -> Fin x -> Fin y)
                                               (\_ f -> f)
                                               n n'
                                               (leibniz pred
                                                        (Succ n) (Succ n') eq_SuccN_SuccN')
                                               f_N))
                              (Succ n')
                              f_SuccN'
                              Refl)

-- head of a vector
let head = \n v -> at (Succ n) v FZero

-- vector map
let map = \f -> vecElim (\n _ -> vec n) Nil (\n x _ rec -> Cons (f x) rec)

-- proofs that 0 is the neutral element of addition
-- one direction is trivial by definition of plus:
-- TODO -- let p0PlusNisN = Refl :: forall {n :: _} . Eq (plus 0 n) n

-- the other direction requires induction on N:
let pNPlus0isN =
  natElim (\n -> Eq (plus n 0) n)
          Refl
          (\n' rec -> leibniz Succ (plus n' 0) n' rec)


primitive Eq :: Type -> Type
primitive eq :: forall {a} {w :: Eq a} . a -> a -> Bool'
let EqD = \a -> a -> a -> Bool'
primitive eq' :: forall {a} . EqD a -> a -> a -> Bool'
primitive eqInt :: EqD Int
primitive eqList :: forall {a} . EqD a -> EqD (List a)

let main_ = eq' (eqList eqInt) (Cons' #3 Nil') Nil'
let main = eq (Cons' #3 Nil') Nil'

primitive Monad :: (Type -> Type) -> Type
primitive return :: forall {m} {a} {w :: Monad m} . a -> m a
primitive MonadD :: (Type -> Type) -> Type
primitive return' :: forall {m} {a} . MonadD m -> a -> m a

primitive IO :: Type -> Type
primitive ReaderT :: Type -> (Type -> Type) -> Type -> Type
primitive monadIO :: MonadD IO
primitive monadReaderT :: forall {r} {m} . MonadD m -> MonadD (ReaderT r m)

let mex_ = return' (monadReaderT monadIO) #3
let mex = return #3 :: IO Int

-- \<a :: Type -> Type> -> \<b :: Monad a> -> \<c :: IO Int ~ a Int> -> return a Int b 3
-- let mex' = return #3 :: ReaderT Bool' IO Int

