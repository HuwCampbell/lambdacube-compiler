let tyType = \(a :: Type) -> a

-- modified version of  http://www.andres-loeh.de/LambdaPi/prelude.lp
let id      = \a -> a
let const   = \x y -> x
let id'     = \a -> id a
let id''    = id id
let app     = \f x -> f x
let comp    = \f g x -> f (g x)
let app2    = \f x y -> f x y
let flip    = \f x y -> f y x
let scomb   = \a b c -> a c (b c)

primitive primFix :: forall (i :: Int) . forall a . (a -> a) -> a
let fix' = fix _

let undefined = fix' id

data Unit :: Type = TT :: Unit
data Empty :: Type = 
data T2 (a :: Type) (b :: Type) :: Type = T2C :: a -> b -> T2 a b
data Sigma (a :: Type) (b :: a -> Type) :: Type = Pair :: forall (x :: a) . b x -> Sigma a b

-- identity function, used for type annotations internally
let typeAnn = \(A :: Type) (a :: A) -> a

data Bool' :: Type = False' :: Bool' ; True' :: Bool'
data List (a :: Type) :: Type = Nil' :: List a ; Cons' :: a -> List a -> List a

primitive primAdd   :: Int -> Int -> Int
primitive primSub   :: Int -> Int -> Int
primitive primMod   :: Int -> Int -> Int
primitive primSqrt  :: Int -> Int
primitive primIntEq :: Int -> Int -> Bool'
primitive primIntLess :: Int -> Int -> Bool'

let dcomp = \(X :: Type) (Y :: X -> Type) (Z :: forall (x :: X) . Y x -> Type) (f :: forall {x} (y :: Y x) . Z x y) (g :: forall (x :: X) . Y x) (x :: X) -> f (g x)
let dcomp' = \{X :: Type} {Y :: X -> Type} {Z :: forall (x :: X) . Y x -> Type} (f :: forall {x} (y :: Y x) . Z x y) (g :: forall (x :: X) . Y x) (x :: X) -> f (g x)
let dcomp'' = (\f g x -> f (g x))
    :: forall {X} {Y :: X -> _} {Z :: forall (x :: X) . Y x -> _}
       (f :: forall {x} (y :: Y x) . Z x y) (g :: forall (x :: X) . Y x) (x :: X)
     . Z x (g x)

let listMap = \f -> fix' (\map -> listCase (\_ -> _) Nil' (\x xs -> Cons' (f x) (map xs)))
let foldr = \c n -> fix' (\foldr -> listCase (\_ -> _) n (\x xs -> c x (foldr xs)))

let concat = \xs ys -> foldr Cons' ys xs

let from    = fix' (\f n -> Cons' n (f (primAdd #1 n)))
let head    = listCase (\_ -> _) undefined (\x _ -> x)
let tail    = listCase (\_ -> _) undefined (\_ xs -> xs)
let nth     = fix' (\f n xs -> bool'Case (\_ -> _)
                     (f (primSub n #1) (tail xs))
                     (head xs)
                     (primIntEq #0 n))
let filter =
  \p -> fix' (\fil -> listCase (\_ -> _) Nil'
        (\x xs -> bool'Case (\_ -> _)
                     (fil xs)
                     (Cons' x (fil xs))
                     (p x)))
let takeWhile =
  \p -> fix' (\tw -> listCase (\_ -> _) Nil'
        (\x xs -> bool'Case (\_ -> _)
                     Nil'
                     (Cons' x (tw xs))
                     (p x)))
let and'    = \a b -> bool'Case (\_ -> _) False' b a
let or'     = \a b -> bool'Case (\_ -> _) b True' a
let not'    = bool'Case (\_ -> _) True' False'
let all     = \p -> fix' (\al -> listCase (\_ -> _) True' (\x xs -> and' (p x) (al xs)))
let intLEq  = \n m -> or' (primIntLess n m) (primIntEq n m)

let primes = fix' (\primes ->
   (Cons' #2 (Cons' #3 (filter (\x -> all (\i -> not' (primIntEq #0 (primMod x i))) (
        takeWhile (\p -> (\m -> or' (primIntLess p m) (primIntEq p m)) (primSqrt x)) primes
    )) (from #5)))
   ))

let nthPrimes = \n -> nth n primes
let int = nthPrimes #10000

data Nat :: Type = Zero :: Nat ; Succ :: Nat -> Nat
data Fin :: Nat -> Type = FZero :: forall {n} . Fin (Succ n) ; FSucc :: forall {n} . Fin n -> Fin (Succ n)
data Vec (a :: Type) :: Nat -> Type = Nil :: Vec a Zero ; Cons :: forall {n} . a -> Vec a n -> Vec a (Succ n)
data Eq {a :: Type} :: a -> a -> Type = Refl :: forall {x} . Eq x x

let vec = Vec _
{-
primitive bool'Case :: forall m . m False' -> m True' -> forall b . m b
primitive listCase  :: forall m . m Nil' -> (forall x xs . m (Cons' x xs)) -> forall b . m b
primitive eqCase :: forall (m :: forall x y . Eq x y -> _) . (forall {x} . m x x Refl) -> forall x y e . m x y e
primitive natCase :: forall m . m Zero -> (forall n . m (Succ n)) -> forall b . m b
-}
primitive natElim :: forall m . m Zero -> (forall n . m n -> m (Succ n)) -> forall b . m b
primitive finElim ::
  forall (m :: forall n . Fin n -> _) .
      (forall {n} . m (Succ n) FZero)
   -> (forall {n} f . m n f -> m (Succ n) (FSucc f))
   -> forall n f . m n f

-- addition of natural numbers
let plus =
  natElim
    (\_ -> _)           -- motive
    (\n -> n)                    -- case for Zero
    (\p rec n -> Succ (rec n))   -- case for Succ

-- predecessor, mapping 0 to 0
let pred =
  natElim
    (\_ -> _)
    Zero
    (\n' _ -> n')

-- a simpler elimination scheme for natural numbers
let natFold =
    \mz ms -> natElim
                   (\_ -> _)
                   mz
                   (\_ rec -> ms rec)

-- an eliminator for natural numbers that has special
-- cases for 0 and 1
let nat1Elim = \m m0 m1 ms -> natElim m m0
                            (\p rec -> natElim (\n -> m (Succ n)) m1 ms p)

-- an eliminator for natural numbers that has special
-- cases for 0, 1 and 2
let nat2Elim = \m m0 m1 m2 ms -> nat1Elim m m0 m1
                                (\p rec -> natElim (\n -> m (Succ (Succ n))) m2 ms p)

-- increment by one
let inc = natFold (Succ Zero) Succ

-- embed Fin into Nat
let finNat = finElim (\_ _ -> Nat)
                     Zero
                     (\_ rec -> Succ rec)

-- unit type
let Unit' = Fin 1
-- constructor
let U = FZero :: Unit'
-- eliminator

let unitElim = \m mu -> finElim (nat1Elim (\n -> Fin n -> Type)
                                 (\_ -> Unit')
                                 (\x -> m x)
                                 (\_ _ _ -> Unit'))
                      (\{n} -> natElim (\n -> natElim (\n -> Fin (Succ n) -> Type)
                                                (\x -> m x)
                                                (\_ _ _ -> Unit')
                                                n FZero)
                                mu
                                (\_ _ -> U) n)
                      (\{n} f _ -> finElim (\n f -> natElim (\n -> Fin (Succ n) -> Type)
                                                             (\x -> m x)
                                                             (\_ _ _ -> Unit')
                                                             n (FSucc f))
                                           U
                                           (\_ _ -> U)
                                           n f)
                      1

-- empty type
let Void = Fin 0
-- eliminator

let voidElim =
  (\m -> finElim (natElim (\n -> Fin n -> Type)
                            (\x -> m x)
                            (\_ _ _ -> _))
                   (\_ -> U)
                   (\_ _ _ -> U)
                   0)

-- type of booleans 
let Bool = Fin 2 
-- constructors
let False = FZero :: Bool
let True  = FSucc FZero :: Bool
-- eliminator

let boolElim = \m mf mt -> finElim ( nat2Elim (\n -> Fin n -> Type)
                                    (\_ -> Unit') (\_ -> Unit')
                                    (\x -> m x)
                                    (\_ _ _ -> Unit'))
                         (\{n} -> nat1Elim (\n -> nat1Elim (\n -> Fin (Succ n) -> Type)
                                                      (\_ -> Unit')
                                                      (\x -> m x)
                                                      (\_ _ _ -> Unit')
                                                      n FZero)
                                    U mf (\_ _ -> U) n)
                         (\{n} f _ -> finElim (\n f -> nat1Elim (\n -> Fin (Succ n) -> Type)
                                                                  (\_ -> Unit')
                                                                  (\x -> m x)
                                                                  (\_ _ _ -> Unit')
                                                                  n (FSucc f))
                                              (\{n} -> natElim
                                                  (\n -> natElim
                                                             (\n -> Fin (Succ (Succ n)) -> Type)
                                                             (\x -> m x)
                                                             (\_ _ _ -> Unit')
                                                             n (FSucc FZero))
                                                  mt (\_ _ -> U) n)
                                              (\{n} f _ -> finElim
                                                             (\n f -> natElim
                                                                         (\n -> Fin (Succ (Succ n)) -> Type)
                                                                         (\x -> m x)
                                                                         (\_ _ _ -> Unit')
                                                                         n (FSucc (FSucc f)))
                                                             U
                                                             (\_ _ -> U)
                                                             n f)
                                              n f)
                         2


-- boolean not, and, or, equivalence, xor
let not = boolElim (\_ -> _) True False
let and = boolElim (\_ -> _) (const False) id
let or  = boolElim (\_ -> _) id (const True)
let iff = boolElim (\_ -> _) not id
let xor = boolElim (\_ -> _) id not

-- even, odd, isZero, isSucc
let even    = natFold True not
let odd     = natFold False not
let isZero  = natFold True (const False)
let isSucc  = natFold False (const True)

-- equality on natural numbers
let natEq =
  natElim
    (\_ -> _)
    (natElim
        (\_ -> _)
        True
        (\n' _ -> False))
    (\m' rec_m' -> natElim
                       (\_ -> _)
                       False
                       (\n' _ -> rec_m' n'))

-- "oh so true"
let Prop = boolElim (\_ -> _) Void Unit'

-- reflexivity of equality on natural numbers
let pNatEqRefl =
  natElim
    (\n -> Prop (natEq n n))
    U
    (\n' rec -> rec)
--  :: forall (n :: Nat) . Prop (natEq n n)

-- alias for type-level negation 
let Not = \a -> a -> Void

-- Leibniz prinicple (look at the type signature)
let leibniz = \f x y -> eqCase
                 (\x y _ -> Eq (f x) (f y))
                 Refl x y

-- symmetry of (general) equality
let symm = eqCase (\x y _ -> Eq y x) Refl

-- transitivity of (general) equality
let tran = \eq_x_y -> eqCase
                          (\x y _ -> forall z . Eq y z -> Eq x z)
                          (\_ x -> x)
                          _ _ eq_x_y _

-- apply an equality proof on two types
let apply = eqCase (\a b _ -> a -> b) id _ _

let p1IsNot0 =
  (\p -> apply
                (leibniz
                         (natElim (\_ -> _) Void (\_ _ -> Unit'))
                         1 0 p)
                U)

-- proof that 0 is not 1
let p0IsNot1 = \p -> p1IsNot0 (symm 0 1 p)

-- proof that zero is not a successor
let p0IsNoSucc = 
  natElim
    (\n -> Not (Eq 0 (Succ n)))
    p0IsNot1
    (\n' rec_n' eq_0_SSn' ->
      rec_n' (leibniz pred Zero (Succ (Succ n')) eq_0_SSn'))

-- generate a vector of given length from a specified element (replicate)

let replicate =
    natElim
      (\n -> forall a . a -> Vec a n)
      (\_ _ -> Nil)
      (\n' rec_n' a x -> Cons x (rec_n' a x))

-- alternative definition of replicate
let replicate' =
    natElim
      (\n -> _ -> vec n)
      (\_ -> Nil)
      (\n' rec_n' x -> Cons x (rec_n' x))

let replicate'' = \x -> natElim vec Nil (\n' rec_n' -> Cons x rec_n')

-- generate a vector of given length n, containing the natural numbers smaller than n
let fromto = natElim vec Nil (\n' rec_n' -> Cons n' rec_n')

primitive vecElim ::
  forall (m :: forall k . vec k -> _) .
         m Zero Nil
         -> (forall {l} x xs . m l xs -> m (Succ l) (Cons x xs))
         -> forall k xs . m k xs

-- append two vectors
let append = vecElim
             (\m _ -> forall n . vec n -> vec (plus m n))
             (\_ v -> v)
             (\v vs rec n w -> Cons v (rec n w))

-- helper function for tail, see below
let tail' =
  \a -> vecElim (\m v -> forall n . Eq m (Succ n) -> Vec a n)
                    (\n eq_0_SuccN -> voidElim (\_ -> _)
                                                 ( p0IsNoSucc n eq_0_SuccN))
                    (\{m'} v vs rec_m' n eq_SuccM'_SuccN ->
                      eqCase
                             (\m' n e -> Vec a m' -> Vec a n)
                             id
                             m' n
                             (leibniz pred (Succ m') (Succ n) eq_SuccM'_SuccN) vs)

-- compute the tail of a vector
let tail = \n v -> tail' _ (Succ n) v n Refl

-- projection out of a vector
let at =
    vecElim (\n v -> Fin n -> _)
                    (\f -> voidElim (\_ -> _) f)
                    (\{n'} v vs rec_n' f_SuccN' ->
                      finElim (\n _ -> Eq n (Succ n') -> _)
                              (\e -> v)
                              (\{n} f_N _ eq_SuccN_SuccN' ->
                                rec_n' (eqCase
                                               (\x y e -> Fin x -> Fin y)
                                               id
                                               n n'
                                               (leibniz pred
                                                        (Succ n) (Succ n') eq_SuccN_SuccN')
                                               f_N))
                              (Succ n')
                              f_SuccN'
                              Refl)

-- head of a vector
let head = \n v -> at (Succ n) v FZero

-- vector map
let map = \f -> vecElim (\n _ -> vec n) Nil (\x _ rec -> Cons (f x) rec)

-- proofs that 0 is the neutral element of addition
-- one direction is trivial by definition of plus:
let p0PlusNisN = Refl :: forall {n} . Eq (plus 0 n) n

-- the other direction requires induction on N:
let pNPlus0isN =
  natElim (\n -> Eq (plus n 0) n)
          Refl
          (\n' rec -> leibniz Succ (plus n' 0) n' rec)


data EqD (a :: Type) :: Type = EqDC :: (a -> a -> Bool') -> EqD a

let eqInt = EqDC primIntEq

primitive Eq :: Type -> Type
primitive eqD :: forall {a} {w :: Eq a} . EqD a

let eq = eqDCase (\_ -> _) id eqD
let eq' = eqDCase (\_ -> _) id

let eqList = EqDC (\as bs -> listCase (\_ -> _) (listCase (\_ -> _) True' (\_ _ -> False') bs) (\a as -> listCase (\_ -> _) False' (\b bs -> and' (eq a b) (eq as bs)) bs) as)

let main_ = eq' eqList (Cons' #3 Nil') Nil'
let main = eq (Cons' #3 Nil') Nil'



data MonadD (m :: Type -> Type) :: Type = MonadDC :: (forall {a} . a -> m a) -> (forall {a} {b} . m a -> (a -> m b) -> m b) -> MonadD m

data Identity (a :: Type) :: Type = IdentityC :: a -> Identity a

let identityMonad = MonadDC IdentityC (\m f -> identityCase (\_ -> _) f m)

let Char = Int

data IO (a :: Type) :: Type
   = IORet :: a -> IO a
   ; PutChar :: Char -> IO a -> IO a
   ; GetChar :: (Char -> IO a) -> IO a

data ReaderT (r :: Type) (m :: Type -> Type) (a :: Type) :: Type = ReaderTC :: (r -> m a) -> ReaderT r m a

-----------------------------

primitive ifIdentity1 :: forall {a} . a -> ((Type -> Type) -> a) -> (Type -> Type) -> a
primitive ifReaderT1 :: forall {a} . (Type -> (Type -> Type) -> a) -> ((Type -> Type) -> a) -> (Type -> Type) -> a

primitive Monad :: (Type -> Type) -> Type
--let Monad = fix' (\Monad -> ifIdentity1 Unit (ifReaderT1 (\r m -> Monad m) (\_ -> Empty)))

----------------- recursive definition
primitive monadD :: forall {m} {w :: Monad m} . MonadD m
-- let monadD = fix' (\monadD {t} -> ifIdentity_1 identityMonad (ifReaderT_1 (\r m -> monadReaderT) undefined t))

let return = monadDCase (\_ -> _) (\r _ -> r) monadD
let bind = monadDCase (\_ -> _) (\_ b -> b) monadD

let monadReaderT = MonadDC (\a -> ReaderTC (\r -> return a))
     (\m f -> ReaderTC (\r -> 
        readerTCase (\_ -> _)
            (\g -> bind
                (g r)
                (\a -> readerTCase (\_ -> _) (\h -> h r) (f a))) 
            m))
--    :: forall {r} {m} {w :: Monad m} . MonadD (ReaderT r m)

-- todo: try to make it recursive
let IOBind = \ma f -> 
      iOCase (\_ -> _)
        f
        (\i r -> PutChar i (bind r f))
        (\g -> GetChar (\i -> bind (g i) f))
        ma

let monadIO = MonadDC IORet IOBind
-------------------------- end of recursive definition

let liftReaderT = \m -> ReaderTC (\r -> m)

let return = monadDCase (\_ -> _) (\r _ -> r) monadD
let bind = monadDCase (\_ -> _) (\_ b -> b) monadD

let bind' = \m m' -> bind m (const m')
let fmap = \f m -> bind m (\x -> return (f x))

let sequence = fix' (\sequence -> listCase (\_ -> _) (return Nil') (\x xs -> bind x (\vx -> fmap (Cons' vx) (sequence xs))))
let sequence_ = fix' (\sequence_ -> listCase (\_ -> _) (return TT) (\x xs -> bind' x (sequence_ xs)))

let mapM = \f -> comp sequence (listMap f)
let mapM_ = \f -> comp sequence_ (listMap f)

let putChar = \i -> PutChar i (return TT)
let getChar = GetChar return

let putStr = mapM_ putChar
let putStrLn = comp putStr (flip concat (Cons' #0 Nil'))
let getLine = fix' (\getLine -> bind getChar (\c -> bool'Case (\_ -> _) (bind getLine (\cs -> return (Cons' c cs))) (return Nil') (eq c #0)))


--let mex_ = return' monadReaderT #3
let mex = return #3 :: IO Int
let mex' = return #3 :: ReaderT Bool' IO Int

let main = bind getLine putStrLn


data Exp :: Type -> Type
    = EInt :: Int -> Exp Int
    ; EApp :: forall {a} {b} . Exp (a -> b) -> Exp a -> Exp b
    ; ECond :: forall {a} . Exp Bool' -> Exp a -> Exp a -> Exp a

-- todo: try to omit fix's argument?
let eval = fix (forall {a} . Exp a -> a) (\eval -> expCase (\b _ -> b)
            (\i -> i)
            (\f a -> eval f (eval a))
            (\b m n -> bool'Case (\_ -> _) (eval n) (eval m) (eval b))
            _)
    :: forall {a} . Exp a -> a

