% LambdaCube 3D compiler developer's documentation and ideas

Compiler structure
==================

Main tasks of the compiler:

-   find errors in source code
    -   semantic errors are ruled out by strong static typing
-   code completion to avoid inferrable parts of code
-   eliminate abstractions (normalization, reduction)

Additional tasks of the compiler:

-   support modular development
    -   modules support
-   support livecoding
    -   highlight errors
    -   inferred types in tooltips
    -   completion
-   additional feedback for users
    -   show desugared source (on a separate tab)
    -   show optimizations (how?)

Design decisions

-   Code generation is not part of the compiler; it is done in the libraries.  
    This helps to keep the compiler smaller and separate domain specific code
    -   reflection support makes this possible
        -   be able to pattern match on different normal forms for more compact description of code generation
    -   a strong type system prevents most misuses, so ideally no error handling is needed during code generation
    -   compilation stages are tracked by the type system
        -   prevents even more misuses
        -   help to speed up compilation?
    -   support different optimization transformations in the libraries
-   the compiler has just two phases
    1.  lexing, parsing, scope checking and desugaring is done in the same phase, sharing the same state
    2.  type checking & inference and normalization is done in the same phase, sharing the same state

Example: Compilation of graphics pipeline descriptions in two phases
--------------------------------------------------------------------

          |
          | source code of code generator for the domain
          | (e.g. code gen. for graphics pipeline descriptions)
          v
        lexer + parser + scope checking + desugaring
          |                                 |
          | desugared source code           |
          v                                 v
    inference + normalization ------> halt with error message (phase #1)
          |
          |  infos for library writers
          |-------------------------->
          |
          | normalized code
          | (code generator)
          |
      /---/
      |
      |   |
      |   | domain language source code
      |   | (e.g. main with type 'graphics pipeline description')
      |   v
      | lexer + parser + scope checking + desugaring
      |   |                                 |
      |   | desugared source code           |
      v   v                                 v
    inference + normalization ------> halt with error message (phase #2)
    (normalization includes reflection of domain lang. code)
          |
          |  infos for live coding
          |-------------------------->
          |
          | normalized code
          | (e.g. graphics pipeline description)
          v


Usecase: Live coding system overview
----------------------------------


           editor frame    WebGL frame
               | ^             ^
    source code| |errors       |
               | | & infos     |pipeline description
               v |             |
             compiler----------/

Try online at [http://lambdacube3d.com/editor.html](http://lambdacube3d.com/editor.html)




Modules support
---------------

[Source code of the driver which handles modules](https://github.com/lambdacube3d/lambdacube-compiler/blob/master/src/LambdaCube/Compiler.hs)

Design decisions

-   module header and body are parsed in two phases
-   module status and availabe information are cached in a map
-   modules can be loaded by filename or by module name
-   builtin modules are always accessible by the last default path element

The module header contains

-   module name
-   export list
-   import list

The driver state contains

-   the paths (in a ReaderT monad transformer)
-   map of cached modules: status + available information (in a StateT monad transformer)
-   fatal error (in an ExceptT monad transformer)

Possible module status

status                                  available information
--------------------------------------- ---------------------------------
file cannot be found                    filename or module name (the paths are available in the driver state) 
header cannot be parsed                 module name, filename, source code
error with loading imported modules     module name, filename, source code, import and export lists (the successfully loaded modules and the error messages are available in the driver state)
body cannot be parsed                   module name, filename, source code, import and export lists, parse error
body cannot be elaborated               module name, filename, source code, import and export lists, desugared body, error message
loaded                                  module name, filename, source code, import and export lists, desugared body, elaborated definitions
--------------------------------------- ---------------------------------


Lexer
=====

[Source code of the lexer](https://github.com/lambdacube3d/lambdacube-compiler/blob/master/src/LambdaCube/Compiler/Lexer.hs)

Tasks

-   pruning white space and comments
-   recognise literals, reserved words and identifiers
-   recognise indentation (case & let expressions, where blocks, ...)
-   calculate ranges (start + end position) of tokens

Design decisions

-   use the `megaparsec` parser combinator library (a better parsec)
-   Lexing and parsing is done in the same phase, sharing the same state  
    how it works: Whitespace is consumed immediately after each "lexeme".
-   do custom indentation sensitive parsing
-   use custom lexer for literals

Indentation sensitive parsing
-----------------------------

State used for indentation sensitive parsing:

-   current position (line + column)
-   current active indentation, in a reader monad

Range calculation
-----------------

State used for calculating ranges:

-   position at the end of the last lexeme


Parsing & desugaring
====================

[Source code of the parser and desugarer](https://github.com/lambdacube3d/lambdacube-compiler/blob/master/src/LambdaCube/Compiler/Parser.hs)

Parser tasks

-   recognise syntactic structures
-   compute ranges of syntactic structures
-   handle namespaces: expression + type namespace

Parser design decisions



Scope checker tasks

-   disambiguate names

Scope checker design decisions

-   scope checking is done by calculating De Bruijn indices

Desugarer tasks

-   handle operator precendences
-   compile patterns and guards into function calls
-   desugar local functions
-   desugar node definitions
-   desugar case expressions
-   desugar let expressions
-   desugar if expressions
-   desugar list comprehensions
-   add missing foralls in type annotations
-   insert wildcards
-   desugar type synonym declarations
-   desugar type family declarations
-   desugar type classes and instances


Desugared source code
---------------------

~~~~~ {.haskell}
data SExp
    = SGlobal SIName
    | SVar SIName Int
    | SBind SI Binder SIName SExp SExp
    | SApp SI Visibility SExp SExp
    | SLet SI SIName SExp SExp
    | SLit SI Lit

data Binder
    = BPi  Visibility
    | BLam Visibility
    | BMeta      -- a metavariable is like a floating hidden lambda

data Stmt
    = Let SIName (Maybe SExp) SExp
    | Data SIName               -- name
           [(Visibility, SExp)] -- parameters
           SExp                 -- type
           [(SIName, SExp)]     -- constructor names and types
    | PrecDef SIName Fixity
~~~~~


Type inference
==============

Tasks

-   find semantic errors
-   complete code
    -   infer types
    -   find out inferrable values
    -   construct witnesses for type class method invocation
-   normalize code
    -   reduce expressions (beta-reduction)
-   avoid infinite recursion (termination checking)  
    (this is not a priority at the moment)


-   code completion is base on supporting hidden arguments


-   eliminate abstractions
    -   reduction, partial evaluation
    -   optimizations
        -   type erasure


    -   optimizations
        -   type erasure

Design decisions

-   use a dependently typed core language (treat types as values)
-   all code completion task is done by inferring values of hidden variables in the following two intermangled phases:
    1.  make every hidden argument application explicit by inserting metavariables
    2.  gradually eliminate metavariables during type checking
-   use a rich environment
-   use a zipper to move around in the environment
-   do type inference and reduction in one step
-   use labels to remember the beginning of right hand side instead of arity information
-   separate types and expressions
-   erease types when possible


Rich environment
----------------



Solving metavariables
---------------------


Insertions of metavariables
---------------------------



Code generation
===============

Currently there is only one code generator, which is wired in the compiler and generates intermediate representation
(called IR or graphics pipeline description)

Tasks

-   generate graphics pipeline descriptions

Design decisions

-   use a custom data type which encapsulates expessions with types and De Bruijn environment



