{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE ViewPatterns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PackageImports #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}  -- TODO: remove
module LambdaCube.Compiler.CoreToIR
    ( compilePipeline
    ) where

import Data.Char
import Data.List
import Data.Maybe
import Data.Monoid
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Vector ((!))
import qualified Data.Vector as Vector
--import Control.Applicative
import Control.Arrow hiding ((<+>))
import Control.Monad.Writer
import Control.Monad.State
import Control.Monad.Reader
--import Control.Monad.Except
--import Control.Monad.Identity
--import Text.Parsec.Pos
--import Debug.Trace

import LambdaCube.IR(Backend(..))
import qualified LambdaCube.IR as IR
import qualified LambdaCube.Linear as IR

import LambdaCube.Compiler.Pretty hiding (parens)
import qualified LambdaCube.Compiler.Infer as I
import LambdaCube.Compiler.Infer (SName, Lit(..), Visibility(..))
import LambdaCube.Compiler.Parser (up, Up (..))

import Data.Version
import Paths_lambdacube_compiler (version)

(<&>) = flip (<$>)

--------------------------------------------------------------------------

type CG = State IR.Pipeline

pattern TFrameBuffer a b <- A2 "FrameBuffer" a b

emptyPipeline b = IR.Pipeline
  { IR.info       = mempty
  , IR.backend    = b
  , IR.textures   = mempty
  , IR.samplers   = mempty
  , IR.targets    = mempty
  , IR.programs   = mempty
  , IR.slots      = mempty
  , IR.streams    = mempty
  , IR.commands   = mempty
  }

update i x xs = xs Vector.// [(i,x)]

newTexture :: Int -> Int -> IR.ImageSemantic -> CG IR.TextureName
newTexture width height semantic = do
  let sampleDescriptor = IR.SamplerDescriptor
        { IR.samplerWrapS       = IR.Repeat
        , IR.samplerWrapT       = Nothing
        , IR.samplerWrapR       = Nothing
        , IR.samplerMinFilter   = IR.Linear 
        , IR.samplerMagFilter   = IR.Linear
        , IR.samplerBorderColor = IR.VV4F (IR.V4 0 0 0 1)
        , IR.samplerMinLod      = Nothing
        , IR.samplerMaxLod      = Nothing
        , IR.samplerLodBias     = 0
        , IR.samplerCompareFunc = Nothing
        }

      textureDescriptor = IR.TextureDescriptor
        { IR.textureType      = IR.Texture2D (if semantic == IR.Color then IR.FloatT IR.RGBA else IR.FloatT IR.Red) 1
        , IR.textureSize      = IR.VV2U $ IR.V2 (fromIntegral width) (fromIntegral height)
        , IR.textureSemantic  = semantic
        , IR.textureSampler   = sampleDescriptor
        , IR.textureBaseLevel = 0
        , IR.textureMaxLevel  = 0
        }
  tv <- gets IR.textures
  modify (\s -> s {IR.textures = tv <> pure textureDescriptor})
  return $ length tv

newFrameBufferTarget :: Ty -> CG IR.RenderTargetName
newFrameBufferTarget (TFrameBuffer _ a) = do
  let t = IR.RenderTarget $ Vector.fromList [IR.TargetItem s (Just (IR.Framebuffer s)) | s <- compSemantics a]
  tv <- gets IR.targets
  modify (\s -> s {IR.targets = tv <> pure t})
  return $ length tv
newFrameBufferTarget x = error $ "newFrameBufferTarget illegal target type: " ++ ppShow x

newTextureTarget :: Int -> Int -> Ty -> CG IR.RenderTargetName
newTextureTarget w h (TFrameBuffer _ a) = do
  tl <- forM (compSemantics a) $ \s -> do
    texture <- newTexture w h s
    return $ IR.TargetItem s (Just (IR.TextureImage texture 0 Nothing))
  tv <- gets IR.targets
  modify (\s -> s {IR.targets = tv <> pure (IR.RenderTarget $ Vector.fromList tl)})
  return $ Vector.length tv
newTextureTarget _ _ x = error $ "newTextureTarget illegal target type: " ++ ppShow x

compilePipeline :: IR.Backend -> I.ExpType -> IR.Pipeline
compilePipeline b e = flip execState (emptyPipeline b) $ do
    (subCmds,cmds) <- getCommands $ toExp e
    modify (\s -> s {IR.commands = Vector.fromList subCmds <> Vector.fromList cmds})
    -- add compiler version to pipeline info
    modify (\s -> s {IR.info = "generated by lambdcube-compiler " ++ showVersion version})

mergeSlot a b = a
  { IR.slotUniforms = IR.slotUniforms a <> IR.slotUniforms b
  , IR.slotStreams  = IR.slotStreams a <> IR.slotStreams b
  , IR.slotPrograms = IR.slotPrograms a <> IR.slotPrograms b
  }

getSlot :: Exp -> CG (IR.Command,[(String,IR.InputType)])
getSlot e@(Prim2 "fetch_" (EString slotName) attrs) = do
  let input = compAttribute attrs
      slot = IR.Slot
        { IR.slotName       = slotName
        , IR.slotUniforms   = mempty
        , IR.slotStreams    = Map.fromList input
        , IR.slotPrimitive  = compFetchPrimitive $ getPrim $ tyOf e
        , IR.slotPrograms   = mempty
        }
  sv <- gets IR.slots
  case Vector.findIndex ((slotName ==) . IR.slotName) sv of
    Nothing -> do
      modify (\s -> s {IR.slots = sv <> pure slot})
      return (IR.RenderSlot $ length sv,input)
    Just i -> do
      modify (\s -> s {IR.slots = update i (mergeSlot (sv ! i) slot) sv})
      return (IR.RenderSlot i,input)
getSlot e@(Prim1 "fetchArrays_" attrs) = do
  let (input,values) = unzip [((name,ty),(name,value)) | (i,(ty,value)) <- zip [0..] (compAttributeValue attrs), let name = "attribute_" ++ show i]
      stream = IR.StreamData
        { IR.streamData       = Map.fromList values
        , IR.streamType       = Map.fromList input
        , IR.streamPrimitive  = compFetchPrimitive $ getPrim $ tyOf e
        , IR.streamPrograms   = mempty
        }
  sv <- gets IR.streams
  modify (\s -> s {IR.streams = sv <> pure stream})
  return (IR.RenderStream $ length sv,input)
getSlot x = error $ "getSlot: " ++ ppShow x

getPrim (A1 "List" (A2 "Primitive" _ p)) = p
getPrim' (A1 "List" (A2 "Primitive" a _)) = a
getPrim'' (A1 "List" (A2 "Vector" _ (A1 "Maybe" (A1 "SimpleFragment" a)))) = a
getPrim'' x = error $ "getPrim'':" ++ ppShow x

addProgramToSlot :: IR.ProgramName -> IR.Command -> CG ()
addProgramToSlot prgName (IR.RenderSlot slotName) = do
  sv <- gets IR.slots
  pv <- gets IR.programs
  let slot = sv ! slotName
      prg = pv ! prgName
      slot' = slot
        { IR.slotUniforms = IR.slotUniforms slot <> IR.programUniforms prg
        , IR.slotPrograms = IR.slotPrograms slot <> pure prgName
        }
  modify (\s -> s {IR.slots = update slotName slot' sv})
addProgramToSlot prgName (IR.RenderStream streamName) = do
  sv <- gets IR.streams
  pv <- gets IR.programs
  let stream = sv ! streamName
      prg = pv ! prgName
      stream' = stream
        { IR.streamPrograms = IR.streamPrograms stream <> pure prgName
        }
  modify (\s -> s {IR.streams = update streamName stream' sv})

getFragFilter (Prim2 "map" (EtaPrim2 "filterFragment" p) x) = (Just p, x)
getFragFilter x = (Nothing, x)

getVertexShader (Prim2 "map" (EtaPrim2 "mapPrimitive" f) x) = (f, x)
getVertexShader x = (idFun $ getPrim' $ tyOf x, x)

getFragmentShader (Prim2 "map" (EtaPrim2 "mapFragment" f) x) = (f, x)
getFragmentShader x = (idFun $ getPrim'' $ tyOf x, x)

removeDepthHandler (Prim2 "map" (EtaPrim1 "noDepth") x) = x
removeDepthHandler x = x

getCommands :: Exp -> CG ([IR.Command],[IR.Command])
getCommands e = case e of
  A1 "ScreenOut" a -> do
    rt <- newFrameBufferTarget (tyOf a)
    (subCmds,cmds) <- getCommands a
    return (subCmds,IR.SetRenderTarget rt : cmds)
  Prim3 "Accumulate" actx (getFragmentShader . removeDepthHandler -> (frag, getFragFilter -> (ffilter, Prim3 "foldr" (Prim0 "++") (A0 "Nil") (Prim2 "map" (EtaPrim3 "rasterizePrimitive" ints rctx) (getVertexShader -> (vert, input)))))) fbuf -> do
    backend <- gets IR.backend
    let rp = compRC' rctx
        (vertexInput, pUniforms, vertSrc, fragSrc) = genGLSLs backend rp ints vert frag ffilter
    (smpBindings, txtCmds) <- getRenderTextureCommands $ Map.toList $ fst <$> pUniforms
    (renderCommand,input) <- getSlot input
    let 
      prg = IR.Program
        { IR.programUniforms    = fmap snd $ Map.filter ((\case UTexture2D{} -> False; _ -> True) . fst) $ pUniforms
        , IR.programStreams     = Map.fromList $ zip vertexInput $ map (uncurry IR.Parameter) input
        , IR.programInTextures  = fmap snd $ Map.filter ((\case UUniform{} -> False; _ -> True) . fst) $ pUniforms
        , IR.programOutput      = pure $ IR.Parameter "f0" IR.V4F -- TODO
        , IR.vertexShader       = unlines vertSrc
        , IR.geometryShader     = mempty -- TODO
        , IR.fragmentShader     = unlines fragSrc
        }
    pv <- gets IR.programs
    modify (\s -> s {IR.programs = pv <> pure prg})
    let prog = length pv
    addProgramToSlot prog renderCommand

    (subFbufCmds, fbufCommands) <- getCommands fbuf
    programs <- gets IR.programs
    let textureUniforms = [IR.SetSamplerUniform n textureUnit | ((n,IR.FTexture2D),textureUnit) <- zip (Map.toList $ IR.programUniforms $ programs ! prog) [0..]]
        cmds =
          [ IR.SetProgram prog ] <>
          textureUniforms <>
          concat -- TODO: generate IR.SetSamplerUniform commands for texture slots
          [ [ IR.SetTexture textureUnit texture
            , IR.SetSamplerUniform name textureUnit
            ] | (textureUnit,(name,IR.TextureImage texture _ _)) <- zip [length textureUniforms..] smpBindings
          ] <>
          [ IR.SetRasterContext (compRC rctx)
          , IR.SetAccumulationContext (compAC actx)
          , renderCommand
          ]
    return (subFbufCmds <> txtCmds, fbufCommands <> cmds)
  Prim1 "FrameBuffer" a -> return ([],[IR.ClearRenderTarget (Vector.fromList $ map (uncurry IR.ClearImage) $ compFrameBuffer a)])
  x -> error $ "getCommands " ++ ppShow x

type SamplerBinding = (IR.UniformName,IR.ImageRef)

getRenderTextureCommands :: [(String, Uniform)] -> CG ([SamplerBinding],[IR.Command])
getRenderTextureCommands = foldM (\(a,b) x -> f x >>= (\(c,d) -> return (c ++ a,d ++ b))) mempty
  where
    f = \case
      (n, UTexture2D w h (getTextureFun -> (a, tf))) -> do
        rt <- newTextureTarget (fromIntegral w) (fromIntegral h) (tyOf a)
        tv <- gets IR.targets
        let IR.RenderTarget (tf . Vector.toList -> IR.TargetItem IR.Color (Just (IR.TextureImage texture _ _))) = tv ! rt
        (subCmds,cmds) <- getCommands a
        return ([(n,IR.TextureImage texture 0 Nothing)], subCmds <> (IR.SetRenderTarget rt:cmds))
      x -> return mempty

    getTextureFun (Prim1 "PrjImageColor" a) = (,) a $ \[_, x] -> x
    getTextureFun (Prim1 "PrjImage" a) = (,) a $ \[x] -> x

compFrameBuffer x = case x of
  ETuple a -> concatMap compFrameBuffer a
  Prim1 "DepthImage" a -> [(IR.Depth, compValue a)]
  Prim1 "ColorImage" a -> [(IR.Color, compValue a)]
  x -> error $ "compFrameBuffer " ++ ppShow x

compSemantics x = case x of
  A2 "Cons" a b -> compSemantic a: compSemantics b
  A0 "Nil" -> []
  x -> error $ "compSemantics: " ++ ppShow x

compSemantic x = case x of
  A1 "Depth" _   -> IR.Depth
  A1 "Stencil" _ -> IR.Stencil
  A1 "Color" _   -> IR.Color
  x -> error $ "compSemantic: " ++ ppShow x

compAC x = IR.AccumulationContext Nothing $ map compFrag $ case x of
  ETuple a -> a
  a -> [a]

compBlending x = case x of
  A0 "NoBlending" -> IR.NoBlending
  A1 "BlendLogicOp" a -> IR.BlendLogicOp (compLO a)
  A3 "Blend" (ETuple [a,b]) (ETuple [ETuple [c,d],ETuple [e,f]]) (compValue -> IR.VV4F g) -> IR.Blend (compBE a) (compBE b) (compBF c) (compBF d) (compBF e) (compBF f) g
  x -> error $ "compBlending " ++ ppShow x

compBF x = case x of
  A0 "Zero'" -> IR.Zero
  A0 "One" -> IR.One
  A0 "SrcColor" -> IR.SrcColor
  A0 "OneMinusSrcColor" -> IR.OneMinusSrcColor
  A0 "DstColor" -> IR.DstColor
  A0 "OneMinusDstColor" -> IR.OneMinusDstColor
  A0 "SrcAlpha" -> IR.SrcAlpha
  A0 "OneMinusSrcAlpha" -> IR.OneMinusSrcAlpha
  A0 "DstAlpha" -> IR.DstAlpha
  A0 "OneMinusDstAlpha" -> IR.OneMinusDstAlpha
  A0 "ConstantColor" -> IR.ConstantColor
  A0 "OneMinusConstantColor" -> IR.OneMinusConstantColor
  A0 "ConstantAlpha" -> IR.ConstantAlpha
  A0 "OneMinusConstantAlpha" -> IR.OneMinusConstantAlpha
  A0 "SrcAlphaSaturate" -> IR.SrcAlphaSaturate
  x -> error $ "compBF " ++ ppShow x

compBE x = case x of
  A0 "FuncAdd" -> IR.FuncAdd
  A0 "FuncSubtract" -> IR.FuncSubtract
  A0 "FuncReverseSubtract" -> IR.FuncReverseSubtract
  A0 "Min" -> IR.Min
  A0 "Max" -> IR.Max
  x -> error $ "compBE " ++ ppShow x

compLO x = case x of
  A0 "Clear" -> IR.Clear
  A0 "And" -> IR.And
  A0 "AndReverse" -> IR.AndReverse
  A0 "Copy" -> IR.Copy
  A0 "AndInverted" -> IR.AndInverted
  A0 "Noop" -> IR.Noop
  A0 "Xor" -> IR.Xor
  A0 "Or" -> IR.Or
  A0 "Nor" -> IR.Nor
  A0 "Equiv" -> IR.Equiv
  A0 "Invert" -> IR.Invert
  A0 "OrReverse" -> IR.OrReverse
  A0 "CopyInverted" -> IR.CopyInverted
  A0 "OrInverted" -> IR.OrInverted
  A0 "Nand" -> IR.Nand
  A0 "Set" -> IR.Set
  x -> error $ "compLO " ++ ppShow x

compComparisonFunction x = case x of
  A0 "Never" -> IR.Never
  A0 "Less" -> IR.Less
  A0 "Equal" -> IR.Equal
  A0 "Lequal" -> IR.Lequal
  A0 "Greater" -> IR.Greater
  A0 "Notequal" -> IR.Notequal
  A0 "Gequal" -> IR.Gequal
  A0 "Always" -> IR.Always
  x -> error $ "compComparisonFunction " ++ ppShow x

pattern EBool a <- (compBool -> Just a)

compBool x = case x of
  A0 "True" -> Just True
  A0 "False" -> Just False
  x -> Nothing

compFrag x = case x of
  A2 "DepthOp" (compComparisonFunction -> a) (EBool b) -> IR.DepthOp a b
  A2 "ColorOp" (compBlending -> b) (compValue -> v) -> IR.ColorOp b v
  x -> error $ "compFrag " ++ ppShow x

compInputType x = case x of
  TFloat          -> IR.Float
  TVec 2 TFloat   -> IR.V2F
  TVec 3 TFloat   -> IR.V3F
  TVec 4 TFloat   -> IR.V4F
  TBool           -> IR.Bool
  TVec 2 TBool    -> IR.V2B
  TVec 3 TBool    -> IR.V3B
  TVec 4 TBool    -> IR.V4B
  TInt            -> IR.Int
  TVec 2 TInt     -> IR.V2I
  TVec 3 TInt     -> IR.V3I
  TVec 4 TInt     -> IR.V4I
  TWord           -> IR.Word
  TVec 2 TWord    -> IR.V2U
  TVec 3 TWord    -> IR.V3U
  TVec 4 TWord    -> IR.V4U
  TMat 2 2 TFloat -> IR.M22F
  TMat 2 3 TFloat -> IR.M23F
  TMat 2 4 TFloat -> IR.M24F
  TMat 3 2 TFloat -> IR.M32F
  TMat 3 3 TFloat -> IR.M33F
  TMat 3 4 TFloat -> IR.M34F
  TMat 4 2 TFloat -> IR.M42F
  TMat 4 3 TFloat -> IR.M43F
  TMat 4 4 TFloat -> IR.M44F
  x -> error $ "compInputType " ++ ppShow x

compAttribute x = case x of
  ETuple a -> concatMap compAttribute a
  Prim1 "Attribute" (EString s) -> [(s, compInputType $ tyOf x)]
  x -> error $ "compAttribute " ++ ppShow x

compAttributeValue :: Exp -> [(IR.InputType,IR.ArrayValue)]
compAttributeValue x = let
    compList (A2 "Cons" a x) = compValue a : compList x
    compList (A0 "Nil") = []
    compList x = error $ "compList: " ++ ppShow x
    emptyArray t | t `elem` [IR.Float,IR.V2F,IR.V3F,IR.V4F,IR.M22F,IR.M23F,IR.M24F,IR.M32F,IR.M33F,IR.M34F,IR.M42F,IR.M43F,IR.M44F] = IR.VFloatArray mempty
    emptyArray t | t `elem` [IR.Int,IR.V2I,IR.V3I,IR.V4I] = IR.VIntArray mempty
    emptyArray t | t `elem` [IR.Word,IR.V2U,IR.V3U,IR.V4U] = IR.VWordArray mempty
    emptyArray t | t `elem` [IR.Bool,IR.V2B,IR.V3B,IR.V4B] = IR.VBoolArray mempty
    emptyArray _ = error "compAttributeValue - emptyArray"
    flatten IR.Float (IR.VFloat x) (IR.VFloatArray l) = IR.VFloatArray $ pure x <> l
    flatten IR.V2F (IR.VV2F (IR.V2 x y)) (IR.VFloatArray l) = IR.VFloatArray $ pure x <> pure y <> l
    flatten IR.V3F (IR.VV3F (IR.V3 x y z)) (IR.VFloatArray l) = IR.VFloatArray $ pure x <> pure y <> pure z <> l
    flatten IR.V4F (IR.VV4F (IR.V4 x y z w)) (IR.VFloatArray l) = IR.VFloatArray $ pure x <> pure y <> pure z <> pure w <> l
    flatten _ _ _ = error "compAttributeValue"
    checkLength l@((a,_):_) = case all (\(i,_) -> i == a) l of
      True  -> snd $ unzip l
      False -> error "FetchArrays array length mismatch!"
    go = \case
      ETuple a -> concatMap go a
      a -> let A1 "List" (compInputType -> t) = tyOf a
               values = compList a
           in
            [(length values,(t,foldr (flatten t) (emptyArray t) values))]
  in checkLength $ go x

compFetchPrimitive x = case x of
  A0 "Point" -> IR.Points
  A0 "Line" -> IR.Lines
  A0 "Triangle" -> IR.Triangles
  A0 "LineAdjacency" -> IR.LinesAdjacency
  A0 "TriangleAdjacency" -> IR.TrianglesAdjacency
  x -> error $ "compFetchPrimitive " ++ ppShow x

compValue x = case x of
  EFloat a -> IR.VFloat $ realToFrac a
  EInt a -> IR.VInt $ fromIntegral a
  A2 "V2" (EFloat a) (EFloat b) -> IR.VV2F $ IR.V2 (realToFrac a) (realToFrac b)
  A3 "V3" (EFloat a) (EFloat b) (EFloat c) -> IR.VV3F $ IR.V3 (realToFrac a) (realToFrac b) (realToFrac c)
  A4 "V4" (EFloat a) (EFloat b) (EFloat c) (EFloat d) -> IR.VV4F $ IR.V4 (realToFrac a) (realToFrac b) (realToFrac c) (realToFrac d)
  A2 "V2" (EBool a) (EBool b) -> IR.VV2B $ IR.V2 a b
  A3 "V3" (EBool a) (EBool b) (EBool c) -> IR.VV3B $ IR.V3 a b c
  A4 "V4" (EBool a) (EBool b) (EBool c) (EBool d) -> IR.VV4B $ IR.V4 a b c d
  x -> error $ "compValue " ++ ppShow x

compRC x = case x of
  A3 "PointCtx" a (EFloat b) c -> IR.PointCtx (compPS a) (realToFrac b) (compPSCO c)
  A2 "LineCtx" (EFloat a) b -> IR.LineCtx (realToFrac a) (compPV b)
  A4 "TriangleCtx" a b c d -> IR.TriangleCtx (compCM a) (compPM b) (compPO c) (compPV d)
  x -> error $ "compRC " ++ ppShow x

compRC' x = case x of
  A3 "PointCtx" a _ _ -> compPS' a
  A4 "TriangleCtx" _ b _ _ -> compPM' b
  x -> defaultPointSizeFun $ case tyOf x of A2 "RasterContext" t _ -> t

compPSCO x = case x of
  A0 "LowerLeft" -> IR.LowerLeft
  A0 "UpperLeft" -> IR.UpperLeft
  x -> error $ "compPSCO " ++ ppShow x

compCM x = case x of
  A0 "CullNone" -> IR.CullNone
  A0 "CullFront" -> IR.CullFront IR.CCW
  A0 "CullBack" -> IR.CullBack IR.CCW
  x -> error $ "compCM " ++ ppShow x

compPM x = case x of
  A0 "PolygonFill" -> IR.PolygonFill
  A1 "PolygonLine" (EFloat a) -> IR.PolygonLine $ realToFrac a
  A1 "PolygonPoint" a  -> IR.PolygonPoint $ compPS a
  x -> error $ "compPM " ++ ppShow x

compPM' x = case x of
  A1 "PolygonPoint" a  -> compPS' a
  x -> defaultPointSizeFun $ case tyOf x of A1 "PolygonMode" t -> t

compPS x = case x of
  A1 "PointSize" (EFloat a) -> IR.PointSize $ realToFrac a
  A1 "ProgramPointSize" _ -> IR.ProgramPointSize
  x -> error $ "compPS " ++ ppShow x

compPS' x = case x of
  A1 "ProgramPointSize" x -> x
  x -> defaultPointSizeFun $ case tyOf x of A1 "PointSize" t -> t

compPO x = case x of
  A2 "Offset" (EFloat a) (EFloat b) -> IR.Offset (realToFrac a) (realToFrac b)
  A0 "NoOffset" -> IR.NoOffset
  x -> error $ "compPO " ++ ppShow x

compPV x = case x of
    A0 "FirstVertex" -> IR.FirstVertex
    A0 "LastVertex" -> IR.LastVertex
    x -> error $ "compPV " ++ ppShow x

--------------------------------------------------------------- GLSL generation

{-
mangleIdent :: String -> String
mangleIdent n = '_': concatMap encodeChar n
  where
    encodeChar = \case
        c | isAlphaNum c -> [c]
        '_'  -> "__"
        '.'  -> "_dot"
        '$'  -> "_dollar"
        '~'  -> "_tilde"
        '='  -> "_eq"
        '<'  -> "_less"
        '>'  -> "_greater"
        '!'  -> "_bang"
        '#'  -> "_hash"
        '%'  -> "_percent"
        '^'  -> "_up"
        '&'  -> "_amp"
        '|'  -> "_bar"
        '*'  -> "_times"
        '/'  -> "_div"
        '+'  -> "_plus"
        '-'  -> "_minus"
        ':'  -> "_colon"
        '\\' -> "_bslash"
        '?'  -> "_qmark"
        '@'  -> "_at"
        '\'' -> "_prime"
        c    -> '$' : show (ord c)
-}

genGLSLs backend
    rp                                              -- program point size
    ints                                            -- interpolations
    vert@(etaRed -> ELam verti (eTuple -> verts@(pos: verto)))   -- vertex shader
    frag@(etaRed -> ELam fragi frago)               -- fragment shader
    ffilter                                         -- fragment filter
    = ( -- vertex input
        vertIn

      , -- uniforms
        fmap (second fst) $ vertUniforms <> fragUniforms

      , -- vertex shader code
           shaderHeader backend
        <> [unwords ["uniform", t, n, ";"] | (n, t) <- Map.toList $ snd . snd <$> vertUniforms]
        <> [unwords [inputDef backend, toGLSLType "3" t, n, ";"] | (n, PVarT t) <- zip vertIn $ getPVars verti]
        <> [unwords $ varyingOut backend i ++ [t, n, ";"] | (n, (i, t)) <- zip vertOut'' vertOut]
        <> ["void main() {"]
        <> [n <> " = " <> x <> ";" | (n, x) <- zip vertOut'' vertGLSL]
        <> ["gl_PointSize = " <> ptGLSL <> ";"]
        <> ["}"]

      , -- fragment shader code
           shaderHeader backend
        <> [unwords ["uniform", t, n, ";"] | (n, t) <- Map.toList $ snd . snd <$> fragUniforms]
        <> [unwords $ varyingIn backend i ++ [t, n, ";"] | (n, (i, t)) <- zip vertOut'' vertOut]
        <> [unwords ["out", toGLSLType "4" $ tyOf frago,fragColorName backend,";"] | noUnit $ tyOf frago, backend == OpenGL33]
        <> ["void main() {"]
        <> ["if (!(" <> filt <> ")) discard;" | Just filt <- [filtGLSL]]
        <> [fragColorName backend <> " = " <> fragGLSL <> ";" | noUnit $ tyOf frago]
        <> ["}"]
      )
  where
    freshTypeVars = map (("s" ++) . show) [0..]

    (((vertGLSL, ptGLSL), vertUniforms), ((filtGLSL, fragGLSL), fragUniforms)) = flip evalState freshTypeVars $ (,)
        <$> (runWriterT $ (,)
            <$> traverse (genGLSL' vertIn . ELam verti) verts
            <*> genGLSL' vertOut'' rp)
        <*> (runWriterT $ (,)
            <$> traverse (genGLSL' (tail vertOut'')) ffilter
            <*> genGLSL' (tail vertOut'') frag)

    vertOut'' = "gl_Position": map (("vo" ++) . show) [1..length vertOut]

    vertIn = map (("vi" ++) . show) [1..length $ getPVars verti]

    genGLSL' vertOut (etaRed -> ELam i@(getPVars -> ps) o)
        | length ps == length vertOut = show <$> genGLSL (reverse vertOut) o
        | otherwise = error $ "makeSubst illegal input " ++ show i ++ "\n" ++ show vertOut

    noUnit TUnit = False
    noUnit _ = True

    vertOut = zipWith go (eTuple ints) verto
      where
        go (A0 n) e = (interpName n, toGLSLType "3" $ tyOf e)

    interpName "Smooth" = "smooth"
    interpName "Flat"   = "flat"
    interpName "NoPerspective" = "noperspective"

    shaderHeader WebGL1 =
         ["#version 100"]
      <> ["precision highp float;"]
      <> ["precision highp int;"]
    shaderHeader OpenGL33 =
         ["#version 330 core"]
      <> ["vec4 texture2D(sampler2D s, vec2 uv){return texture(s,uv);}"]

    fragColorName WebGL1   = "gl_FragColor"
    fragColorName OpenGL33 = "f0"

    inputDef WebGL1   = "attribute"
    inputDef OpenGL33 = "in"

    varyingIn WebGL1 _   = ["varying"]
    varyingIn OpenGL33 i = [i, "in"]

    varyingOut WebGL1   _ = ["varying"]
    varyingOut OpenGL33 i = [i, "out"]

genGLSLs _ _ _ _ _ _ = error $ "genGLSLs " -- ++ show e --ppShow e

defaultPointSizeFun t = ELam (ptuple t) $ EFloat 1
idFun t = Lam Visible (PVar t) t (Var 0 t)

ptuple (AN (tupName -> Just _) xs) = PTuple [ptuple t | t <- xs]
ptuple t = PVar t

eTuple (ETuple l) = l
eTuple x = [x]

getPVars = \case
    PTuple l -> l
    PVar TUnit -> []
    x -> [x]

parens a = "(" <+> a <+> ")"

data Uniform
    = UUniform
    | UTexture2DSlot
    | UTexture2D Integer Integer Exp
    deriving (Show)

type Uniforms = Map String (Uniform, (IR.InputType, String))

genGLSL :: [SName] -> Exp -> WriterT Uniforms (State [String]) Doc
genGLSL dns e = case e of

  Prim1 "Uniform" (EString s) -> do
    tell $ Map.singleton s $ (,) UUniform (compInputType $ tyOf e, toGLSLType "1" $ tyOf e)
    pure $ text s
  A3 "Sampler" _ _ (A1 "Texture2DSlot" (EString s)) -> do
    tell $ Map.singleton s $ (,) UTexture2DSlot (IR.FTexture2D{-compInputType $ tyOf e  -- TODO-}, "sampler2D")
    pure $ text s
  A3 "Sampler" _ _ (A2 "Texture2D" (A2 "V2" (EInt w) (EInt h)) b) -> do
    s <- newName
    tell $ Map.singleton s $ (,) (UTexture2D w h b) (IR.FTexture2D, "sampler2D")
    pure $ text s

  ELit a -> pure $ text $ show a
  Var i _ -> pure $ text $ dns !! i

  -- texturing
  A3 "Sampler" _ _ _ -> error "sampler GLSL codegen is not supported"
  PrimN "texture2D" xs -> functionCall "texture2D" xs

  -- temp builtins FIXME: get rid of these
  Prim1 "primIntToWord" a -> error $ "WebGL 1 does not support uint types: " ++ ppShow e
  Prim1 "primIntToFloat" a -> gen a -- FIXME: does GLSL support implicit int to float cast???
  Prim2 "primCompareInt" a b -> error $ "GLSL codegen does not support: " ++ ppShow e
  Prim2 "primCompareWord" a b -> error $ "GLSL codegen does not support: " ++ ppShow e
  Prim2 "primCompareFloat" a b -> error $ "GLSL codegen does not support: " ++ ppShow e
  Prim1 "primNegateInt" a -> (text "-" <+>) . parens <$> (gen a)
  Prim1 "primNegateWord" a -> error $ "WebGL 1 does not support uint types: " ++ ppShow e
  Prim1 "primNegateFloat" a -> (text "-" <+>) . parens <$> (gen a)

  -- vectors
  AN n xs | n `elem` ["V2", "V3", "V4"], Just f <- vecConName $ tyOf e -> functionCall f xs
  -- bool
  A0 "True"  -> pure $ text "true"
  A0 "False" -> pure $ text "false"
  -- matrices
  AN "M22F" xs -> functionCall "mat2" xs
  AN "M23F" xs -> error "WebGL 1 does not support matrices with this dimension"
  AN "M24F" xs -> error "WebGL 1 does not support matrices with this dimension"
  AN "M32F" xs -> error "WebGL 1 does not support matrices with this dimension"
  AN "M33F" xs -> functionCall "mat3" xs
  AN "M34F" xs -> error "WebGL 1 does not support matrices with this dimension"
  AN "M42F" xs -> error "WebGL 1 does not support matrices with this dimension"
  AN "M43F" xs -> error "WebGL 1 does not support matrices with this dimension"
  AN "M44F" xs -> functionCall "mat4" xs -- where gen = gen

  Prim3 "primIfThenElse" a b c -> hsep <$> sequence [gen a, pure "?", gen b, pure ":", gen c]
  -- TODO: Texture Lookup Functions
  SwizzProj a x -> gen a <&> \a -> "(" <+> a <+> (")." <> text x)
  ELam _ _ -> error "GLSL codegen for lambda function is not supported yet"
  Let{} -> error "GLSL codegen for let is not supported yet"
  ETuple _ -> pure $ error "GLSL codegen for tuple is not supported yet"

  -- Primitive Functions
  PrimN "==" xs -> binOp "==" xs
  PrimN ('P':'r':'i':'m':n) xs | n'@(_:_) <- trName (dropS n) -> case n' of
      (c:_) | isAlpha c -> functionCall n' xs
      [op, '_']         -> prefixOp [op] xs
      n'                -> binOp n' xs
    where
      ifType p a b = if all (p . tyOf) xs then a else b

      dropS n
        | last n == 'S' && init n `elem` ["Add", "Sub", "Div", "Mod", "BAnd", "BOr", "BXor", "BShiftL", "BShiftR", "Min", "Max", "Clamp", "Mix", "Step", "SmoothStep"] = init n
        | otherwise = n

      trName = \case

        -- Arithmetic Functions
        "Add"               -> "+"
        "Sub"               -> "-"
        "Neg"               -> "-_"
        "Mul"               -> ifType isMatrix "matrixCompMult" "*"
        "MulS"              -> "*"
        "Div"               -> "/"
        "Mod"               -> ifType isIntegral "%" "mod"

        -- Bit-wise Functions
        "BAnd"              -> "&"
        "BOr"               -> "|"
        "BXor"              -> "^"
        "BNot"              -> "~_"
        "BShiftL"           -> "<<"
        "BShiftR"           -> ">>"

        -- Logic Functions
        "And"               -> "&&"
        "Or"                -> "||"
        "Xor"               -> "^"
        "Not"               -> ifType isScalar "!_" "not"

        -- Integer/Float Conversion Functions
        "FloatBitsToInt"    -> "floatBitsToInt"
        "FloatBitsToUInt"   -> "floatBitsToUint"
        "IntBitsToFloat"    -> "intBitsToFloat"
        "UIntBitsToFloat"   -> "uintBitsToFloat"

        -- Matrix Functions
        "OuterProduct"      -> "outerProduct"
        "MulMatVec"         -> "*"
        "MulVecMat"         -> "*"
        "MulMatMat"         -> "*"

        -- Fragment Processing Functions
        "DFdx"              -> "dFdx"
        "DFdy"              -> "dFdy"

        -- Vector and Scalar Relational Functions
        "LessThan"          -> ifType isScalarNum "<"  "lessThan"
        "LessThanEqual"     -> ifType isScalarNum "<=" "lessThanEqual"
        "GreaterThan"       -> ifType isScalarNum ">"  "greaterThan"
        "GreaterThanEqual"  -> ifType isScalarNum ">=" "greaterThanEqual"
        "Equal"             -> "=="
        "EqualV"            -> ifType isScalar "==" "equal"
        "NotEqual"          -> "!="
        "NotEqualV"         -> ifType isScalar "!=" "notEqual"

        -- Angle and Trigonometry Functions
        "ATan2"             -> "atan"
        -- Exponential Functions
        "InvSqrt"           -> "inversesqrt"
        -- Common Functions
        "RoundEven"         -> "roundEven"
        "ModF"              -> error "PrimModF is not implemented yet!" -- TODO
        "MixB"              -> "mix"

        n | n `elem`
            -- Logic Functions
            [ "Any", "All"
            -- Angle and Trigonometry Functions
            , "ACos", "ACosH", "ASin", "ASinH", "ATan", "ATanH", "Cos", "CosH", "Degrees", "Radians", "Sin", "SinH", "Tan", "TanH"
            -- Exponential Functions
            , "Pow", "Exp", "Exp2", "Log2", "Sqrt"
            -- Common Functions
            , "IsNan", "IsInf", "Abs", "Sign", "Floor", "Trunc", "Round", "Ceil", "Fract", "Min", "Max", "Mix", "Step", "SmoothStep"
            -- Geometric Functions
            , "Length", "Distance", "Dot", "Cross", "Normalize", "FaceForward", "Reflect", "Refract"
            -- Matrix Functions
            , "Transpose", "Determinant", "Inverse"
            -- Fragment Processing Functions
            , "FWidth"
            -- Noise Functions
            , "Noise1", "Noise2", "Noise3", "Noise4"
            ] -> map toLower n

        _ -> ""

  x -> error $ "GLSL codegen - unsupported expression: " ++ ppShow x
  where
    newName = gets head <* modify tail

    prefixOp o [a] = (text o <+>) . parens <$> (gen a)
    binOp o [a, b] = hsep <$> sequence [parens <$> gen a, pure $ text o, parens <$> gen b]
    functionCall f a = (text f <+>) . parens . hcat . intersperse "," <$> mapM gen a

    gen = genGLSL dns

isMatrix :: Ty -> Bool
isMatrix TMat{} = True
isMatrix _ = False

isIntegral :: Ty -> Bool
isIntegral TWord = True
isIntegral TInt = True
isIntegral (TVec _ TWord) = True
isIntegral (TVec _ TInt) = True
isIntegral _ = False

isScalarNum :: Ty -> Bool
isScalarNum = \case
    TInt -> True
    TWord -> True
    TFloat -> True
    _ -> False

isScalar :: Ty -> Bool
isScalar = isJust . scalarType

scalarType = \case
    TBool  -> Just "b"
    TWord  -> Just "u"
    TInt   -> Just "i"
    TFloat -> Just ""
    _ -> Nothing

vecConName = \case
    TVec n t | is234 n, Just s <- scalarType t -> Just $ s ++ "vec" ++ show n
    t -> Nothing

toGLSLType msg = \case
    TBool  -> "bool"
    TWord  -> "uint"
    TInt   -> "int"
    TFloat -> "float"
    x@(TVec n t) | Just s <- vecConName x -> s
    TMat i j TFloat | is234 i && is234 j -> "mat" ++ if i == j then show i else show i ++ "x" ++ show j
    TTuple []         -> "void"
    t -> error $ "toGLSLType: " ++ msg ++ " " ++ ppShow t

is234 = (`elem` [2,3,4])


--------------------------------------------------------------------------------

{-
-   type in Var
-   types
-   no erasure
-}


data Exp_ a
    = Pi_ Visibility SName a a
    | Lam_ Visibility Pat a a
    | Con_ SName a [a]
    | ELit_ Lit
    | Fun_ SName a [a] (Maybe a)
    | App_ a a
    | Var_ Int a
    | TType_
    | Let_ SName a
  deriving (Show, Eq, Functor, Foldable, Traversable)

instance PShow Exp where
    pShowPrec p = \case
        Var i t -> text $ "v" ++ show i
        TType -> "Type"
        ELit a -> text $ show a
        AN n ps -> pApps p (text n) ps
        PrimN n ps -> pApps p (text n) ps
--        Con n t ps -> pApps p (text n) ps
--        Fun n t ps -> pApps p (text n) ps
        EApp a b -> pApp p a b
        Lam h n t e -> pParens True $ "\\" <> showVis h <> pShow n </> "->" <+> pShow e
        Pi h n t e -> pParens True $ showVis h <> pShow n </> "->" <+> pShow e
        Let pat x -> pParens (p > 0) $ "let" <+> text pat </> "=" <+> pShow x
      where
        showVis Visible = ""
        showVis Hidden = "@"

pattern Pi h n a b = Exp (Pi_ h n a b)
pattern Lam h n a b = Exp (Lam_ h n a b)
pattern Con n a b = Exp (Con_ (UntickName n) a b)
pattern ELit a = Exp (ELit_ a)
pattern Fun n a b md = Exp (Fun_ (UntickName n) a b md)
pattern EApp a b = Exp (App_ a b)
pattern Var a b = Exp (Var_ a b)
pattern TType = Exp TType_
pattern Let a b = Exp (Let_ a b)

instance Up Exp where
    up_ n = f where
        f i e = case e of
            Var k b -> Var (if k >= i then k+n else k) $ f i b
            Lam h n t e -> Lam h n (f i t) (f (i+1) e)
            Pi h n t e -> Pi h n (f i t) (f (i+1) e)
            Fun n t xs mx -> Fun n (f i t) (f i <$> xs) (f i <$> mx)
            Con n t xs -> Con n (f i t) (f i <$> xs)
            Let a b -> Let a (f i b)
            EApp a b -> EApp (f i a) (f i b)
            x@TType{} -> x
            x@ELit{} -> x

instance I.Subst Exp Exp where
    subst i0 x = f i0
      where
        f i e = case e of
            Lam h n a b -> Lam h n (f i a) (f (i+1) b)
            Pi h n a b -> Pi h n (f i a) (f (i+1) b)
            Con n t xs  -> Con n (f i t) (f i <$> xs)
            Fun n t xs mx  -> Fun n (f i t) (f i <$> xs) (f i <$> mx)
            Var k b -> case compare k i of GT -> Var (k - 1) (f i b); LT -> Var k (f i b); EQ -> up (i - i0) x
            Let a b -> Let a (f i b)
            EApp a b -> app' (f i a) (f i b)
            x@TType{} -> x
            x@ELit{} -> x

tyApp (Pi _ n a b) x = I.subst 0 x b

app' (Lam _ (PVarr) _ x) b = I.subst 0 b x
app' a b = EApp a b

pattern UntickName n <- (untick -> n) where UntickName = untick

pattern EString s = ELit (LString s)
pattern EFloat s = ELit (LFloat s)
pattern EInt s = ELit (LInt s)

newtype Exp' = Exp' (Exp_ Exp')
  deriving (Show, Eq)

type Exp = Exp'
pattern Exp a = Exp' a

makeTE [] = I.EGlobal (error "makeTE - no source") I.initEnv $ error "makeTE"
makeTE ((_, t): vs) = I.EBind2 (I.BLam Visible) t $ makeTE vs

toExp :: I.ExpType -> Exp
toExp = flip runReader [] . f_
  where
    f_ (e, et) = f__ (e, et)
    f__ (e, et) = case e of
        I.Var i -> asks $ up i . fst . (!!! i)
--        I.Pi b x (I.down 0 -> Just y) -> Pi b "" <$> f_ (x, I.TType) <*> f_ (y, I.TType)
        I.Pi b x y -> do
            t <- f_ (x, I.TType)
            Pi b "?" t <$> local ((Var 0 t, x):) (f_ (y, I.TType))
        I.Lam y -> case et of
            I.Pi b x yt -> do
                t <- f_ (x, I.TType)
                Lam b (PVar t) t <$> local ((Var 0 t, x):) (f_ (y, yt))
        I.Con s n xs    -> Con (show s) <$> f_ (t, I.TType) <*> chain "con" [] t (I.mkConPars n et ++ xs)
          where t = I.conType et s
        I.TyCon s xs    -> Con (show s) <$> f_ (I.nType s, I.TType) <*> chain "tycon" [] (I.nType s) xs
        I.Neut (I.Fun s i xs def) -> Fun (show s) <$> f_ (I.nType s, I.TType) <*> chain "fun" [] (I.nType s) xs <*> mkDef i def et
        I.CaseFun s xs n -> asks makeTE >>= \te -> Fun (show s) <$> f_ (I.nType s, I.TType) <*> chain "case" [] (I.nType s) (I.makeCaseFunPars te n ++ xs ++ [I.Neut n]) <*> pure Nothing
        I.TyCaseFun s [m, t, f] n -> asks makeTE >>= \te -> Fun (show s) <$> f_ (I.nType s, I.TType) <*> chain "tycase" [] (I.nType s) ([m, t, I.Neut n, f]) <*> pure Nothing
        I.Neut (I.App_ a b) -> asks makeTE >>= \te -> do
            let t = I.neutType te a
            app' <$> f_ (I.Neut a, t) <*> (head <$> chain "app" [] t [b])
        I.ELit l -> pure $ ELit l
        I.TType -> pure TType
        I.FixLabel_ _ _ _ x -> f_ (x, et)
        I.LabelEnd x -> f_ (x, et)
        z -> error $ "toExp: " ++ show z

    mkDef i I.Delta _ = return Nothing
    mkDef i _ _ = return Nothing
--    mkDef i def et = Just <$> f_ (iterateN i I.Lam $ I.Neut def, et)

    chain e acc t [] = return $ reverse acc
    chain e acc t@({-I.unfixlabel -> -} I.Pi b at y) (a: as) = do
        a' <- f_ (a, at)
        chain e (a': acc) (I.appTy t a) as
    chain e acc t _ = error $ "chain: " ++ e ++ show t

    xs !!! i | i < 0 || i >= length xs = error $ show xs ++ " !! " ++ show i
    xs !!! i = xs !! i

isSampler (I.TyCon n _) = show n == "'Sampler"
isSampler _ = False

untick ('\'': s) = s
untick s = s

freeVars :: Exp -> Set.Set Int
freeVars = \case
    Var _ _ -> Set.singleton 0
    Con _ _ xs -> mconcat $ map freeVars xs
    ELit _ -> mempty
    Fun _ _ xs md -> foldMap freeVars xs <> foldMap freeVars md
    EApp a b -> freeVars a <> freeVars b
    Pi _ n a b -> freeVars a <> (lower $ freeVars b)
    Lam _ PVarr a b -> freeVars a <> (lower $ freeVars b)
    TType -> mempty
    Let _ a -> freeVars a
  where
    lower = Set.map (+(-1)) . Set.filter (>0)

type Ty = Exp

tyOf :: Exp -> Ty
tyOf = \case
    Lam h (PVarr) t x -> Pi h "?" t $ tyOf x
    EApp f x -> tyApp (tyOf f) x
    Var _ t -> t
    Pi{} -> TType
    Con _ t xs -> foldl tyApp t xs
    Fun _ t xs _ -> foldl tyApp t xs
    ELit l -> toExp (I.litType l, I.TType)
    TType -> TType
    Let a b -> tyOf b
    x -> error $ "tyOf: " ++ ppShow x

-------------------------------------------------------------------------------- Exp conversion -- TODO: remove

data Pat
    = PVar_ Exp
    | PTuple [Pat]
    deriving (Eq, Show)

pattern PVar e = PVar_ e

instance PShow Pat where
    pShowPrec p = \case
        PVar t -> text "?"
        PTuple ps -> tupled $ map pShow ps

pattern PVarT t <- PVar t
pattern PVarr <- PVar _

patTy (PVarT t) = t
patTy (PTuple ps) = Con ("Tuple" ++ show (length ps)) (tupTy $ length ps) $ map patTy ps

tupTy n = foldr (:~>) TType $ replicate n TType

-- workaround for backward compatibility
etaRed (ELam (PVarr) (EApp f (EVar' 0))) | 0 `Set.notMember` freeVars f = downE f
etaRed (ELam (PVarr) (Prim3 (tupCaseName -> Just k) _ x (EVar' 0))) | 0 `Set.notMember` freeVars x = uncurry (\ps e -> ELam (PTuple ps) e) $ getPats k $ downE x
etaRed x = x

getPats 0 e = ([], e)
getPats i (ELam p e) = first (p:) $ getPats (i-1) e

downE = I.subst 0 (error "impossible" :: Exp)

pattern EtaPrim1 s <- (getEtaPrim -> Just (s, []))
pattern EtaPrim2 s x <- (getEtaPrim -> Just (s, [x]))
pattern EtaPrim3 s x1 x2 <- (getEtaPrim -> Just (s, [x1, x2]))
pattern EtaPrim4 s x1 x2 x3 <- (getEtaPrim -> Just (s, [x1, x2, x3]))
pattern EtaPrim5 s x1 x2 x3 x4 <- (getEtaPrim -> Just (s, [x1, x2, x3, x4]))
pattern EtaPrim2_2 s <- (getEtaPrim2 -> Just (s, []))

getEtaPrim (ELam (PVarr) (PrimN s (initLast -> Just (xs, EVar' 0)))) | all (Set.notMember 0 . freeVars) xs = Just (s, I.subst 0 (error "impossible" :: Exp) <$> xs)
getEtaPrim _ = Nothing

getEtaPrim2 (ELam (PVarr) (ELam (PVarr) (PrimN s (initLast -> Just (initLast -> Just (xs, EVar' 0), EVar' 0))))) | all (\x -> all (`Set.notMember` freeVars x) [0, 1]) xs = Just (s, I.subst 0 (error "impossible" :: Exp) . I.subst 0 (error "impossible" :: Exp) <$> xs)
getEtaPrim2 _ = Nothing

initLast [] = Nothing
initLast xs = Just (init xs, last xs)

tupCaseName "Tuple2Case" = Just 2
tupCaseName "Tuple3Case" = Just 3
tupCaseName "Tuple4Case" = Just 4
tupCaseName "Tuple5Case" = Just 5
tupCaseName "Tuple6Case" = Just 6
tupCaseName "Tuple7Case" = Just 7
tupCaseName _ = Nothing

-------------

pattern EVar' n <- Var n _

pattern ELam n b <- Lam Visible n _ b where ELam n b = Lam Visible n (patTy n) b

pattern a :~> b = Pi Visible "" a b
infixr 1 :~>

pattern PrimN n xs <- Fun n t (filterRelevant t -> xs) _ where PrimN n xs = Fun n (builtinType n) xs Nothing
pattern Prim0 n = PrimN n []
pattern Prim1 n a = PrimN n [a]
pattern Prim2 n a b = PrimN n [a, b]
pattern Prim3 n a b c <- PrimN n [a, b, c]
pattern Prim4 n a b c d <- PrimN n [a, b, c, d]
pattern Prim5 n a b c d e <- PrimN n [a, b, c, d, e]

builtinType = \case
    "Output"    -> TType
    "Bool"      -> TType
    "Float"     -> TType
    "Nat"       -> TType
    "Zero"      -> TNat
    "Succ"      -> TNat :~> TNat
    "String"    -> TType
    "Sampler"   -> TType
    "VecS"      -> TType :~> TNat :~> TType
    n -> error $ "type of " ++ ppShow n

filterRelevant _ [] = []
filterRelevant ty@(Pi h n t t') (x: xs) = (if h == Visible then (x:) else id) $ filterRelevant (tyApp ty x) xs

pattern AN n xs <- Con n t (filterRelevant t -> xs) where AN n xs = Con n (builtinType n) xs
pattern A0 n = AN n []
pattern A1 n a = AN n [a]
pattern A2 n a b = AN n [a, b]
pattern A3 n a b c = AN n [a, b, c]
pattern A4 n a b c d <- AN n [a, b, c, d]
pattern A5 n a b c d e <- AN n [a, b, c, d, e]

pattern TUnit  <- A0 "Tuple0"
pattern TBool  = A0 "Bool"
pattern TWord  <- A0 "Word"
pattern TInt   <- A0 "Int"
pattern TNat   = A0 "Nat"
pattern TFloat = A0 "Float"
pattern TString = A0 "String"

pattern Zero = A0 "Zero"
pattern Succ n = A1 "Succ" n

pattern TVec n a = A2 "VecS" a (Nat n)
pattern TMat i j a <- A3 "Mat" (Nat i) (Nat j) a

pattern Nat n <- (fromNat -> Just n) where Nat = toNat

toNat :: Int -> Exp
toNat 0 = Zero
toNat n = Succ (toNat $ n-1)

fromNat :: Exp -> Maybe Int
fromNat Zero = Just 0
fromNat (Succ n) = (1 +) <$> fromNat n
fromNat _ = Nothing

pattern TTuple xs <- (getTuple -> Just xs)
pattern ETuple xs <- (getTuple -> Just xs)

getTuple (AN (tupName -> Just n) xs) | length xs == n = Just xs
getTuple _ = Nothing

tupName = \case
    "Tuple0" -> Just 0
    "Tuple2" -> Just 2
    "Tuple3" -> Just 3
    "Tuple4" -> Just 4
    "Tuple5" -> Just 5
    "Tuple6" -> Just 6
    "Tuple7" -> Just 7
    _ -> Nothing

pattern SwizzProj a b <- (getSwizzProj -> Just (a, b))

getSwizzProj = \case
    Prim2 "swizzscalar" e (getSwizzChar -> Just s) -> Just (e, [s])
    Prim2 "swizzvector" e (AN ((`elem` ["V2","V3","V4"]) -> True) (traverse getSwizzChar -> Just s)) -> Just (e, s)
    _ -> Nothing

getSwizzChar = \case
    A0 "Sx" -> Just 'x'
    A0 "Sy" -> Just 'y'
    A0 "Sz" -> Just 'z'
    A0 "Sw" -> Just 'w'
    _ -> Nothing

